#include "MonoPhotonProcessor.h"
#include <iostream>
#include <map>

#include <EVENT/LCCollection.h>
#include <EVENT/ReconstructedParticle.h>

// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"

#ifdef MARLIN_USE_AIDA
#include <marlin/AIDAProcessor.h>
#include <AIDA/IHistogramFactory.h>
#include <AIDA/ICloud1D.h>

//#include <AIDA/IHistogram1D.h>
#endif // MARLIN_USE_AIDA

#include "TFile.h"
#include "TTree.h"
#include "TMath.h"
#include "TVector3.h"

using namespace lcio ;
using namespace marlin ;


MonoPhotonProcessor aMonoPhotonProcessor ;


MonoPhotonProcessor::MonoPhotonProcessor() : Processor("MonoPhotonProcessor") {

    // modify processor description
    _description = "MonoPhotonProcessor does whatever it does ..." ;


    // register steering parameters: name, description, class-variable, default value
    registerInputCollection( LCIO::MCPARTICLE,
            "InputMCParticleCollection" , 
            "Name of the MCParticle collection"  ,
            _colMCP ,
            std::string("MCParticle")
    );

    registerInputCollection( LCIO::RECONSTRUCTEDPARTICLE,
  	   "InputPFOCollection" , 
  	   "Name of the PFOs collection"  ,
  	   _colPFO ,
  	   std::string("PandoraPFOs") 
    ) ;

    registerInputCollection( LCIO::RECONSTRUCTEDPARTICLE,
  	   "InputBCalRecoCollection" , 
  	   "Name of the BCalReco collection"  ,
  	   _colBCal ,
  	   std::string("BCalRecoParticle") 
    ) ;

    registerInputCollection( LCIO::LCRELATION,
	   "InputMCTruthLinkCollection" , 
  	   "Name of the MCTruthLink collection"  ,
  	   _colMCPFORelation ,
  	   std::string("RecoMCTruthLink") 
    ) ;

    registerProcessorParameter( "OutputRootFileName",
           "Name of Root file (default: output.root)",
           _rootfilename, 
           std::string("output.root")
    );

    registerProcessorParameter( "BoostAngle",
           "Angle defined w.r.t z-axis in x direction. 14 mrad crossing angle (ILD) case, this parameter should be -0.007 to be BCal coordinates from ILD coordinates (default: -0.007)",
           _boostAngle, 
           float(-0.007)
    );

}



void MonoPhotonProcessor::init() { 

    streamlog_out(DEBUG) << "   init called  " << std::endl ;

    // usually a good idea to
    printParameters() ;

    _nRun = 0 ;
    _nEvt = 0 ;

    _navpfo = 0;

    makeNTuple();

    _g = TMath::Sqrt(1. + (TMath::Tan(_boostAngle)*TMath::Tan(_boostAngle)));
    _bg = TMath::Tan(_boostAngle);
}


void MonoPhotonProcessor::processRunHeader( LCRunHeader* run) { 

    _nRun++ ;
} 



void MonoPhotonProcessor::processEvent( LCEvent * evt ) { 
    _nEvt ++ ;

    // this gets called for every event 
    // usually the working horse ...

    // Clear memory
    memset( &_data, 0, sizeof(_data) );

    // try to get lcio collection (exits if collection is not available)
    // NOTE: if the AIDAProcessor is activated in your steering file and Marlin is linked with
    //      RAIDA you may get the message: "*** Break *** segmentation violation" followed by a
    //      stack-trace (generated by ROOT) in case the collection is unavailable. This happens
    //      because ROOT is somehow catching the exit signal commonly used to exit a program
    //      intentionally. Sorry if this messsage may confuse you. Please ignore it!
    LCCollection* colmcp = evt->getCollection( _colMCP ) ;
    //LCCollection* colpfo = 0;
    //colpfo = evt->getCollection( _colPFO ) ;
    //LCCollection* colmcpforel = evt->getCollection( _colMCPFORelation ) ;
    LCCollection* colmcpforel = NULL;
    try{
      colmcpforel = evt->getCollection( _colMCPFORelation ) ;
    }
    catch( lcio::DataNotAvailableException e )
    {
        streamlog_out(WARNING) << _colMCPFORelation << " collection not available" << std::endl;
        colmcpforel = NULL;
    }

    LCCollection* colpfo = NULL;
    try{
        colpfo = evt->getCollection( _colPFO );
    }
    catch( lcio::DataNotAvailableException e )
    {
        streamlog_out(WARNING) << _colPFO << " collection not available" << std::endl;
        colpfo = NULL;
    }

    LCCollection* colbcal = NULL;
    try{
        colbcal = evt->getCollection( _colBCal );
    }
    catch( lcio::DataNotAvailableException e )
    {
        streamlog_out(WARNING) << _colBCal << " collection not available" << std::endl;
        colbcal = NULL;
    }

    // this will only be entered if the collection is available
    if( colmcp != NULL ){

        int nMCP = colmcp->getNumberOfElements()  ;
        if (nMCP > NMAX_MCPS) {
           std::cerr << " !!! ERROR nMCP ( = " << nMCP << ") exceeds NMAX_MCPS ( = " << NMAX_MCPS << ")." << std::endl;
           std::abort();
        }
        _data.nmcps = nMCP;

        if (nMCP>0) {
          MCParticle* beam = dynamic_cast<MCParticle*>( colmcp->getElementAt( 0 ) ) ;
          _data.ipx = getIP(beam).X(); 
          _data.ipy = getIP(beam).Y(); 
          _data.ipz = getIP(beam).Z(); 
        }
        // create MCParticle pointer and indices in MCParticle collection
        _mcpmap.clear();
        for(int i=0; i< nMCP ; i++){
           MCParticle* p = dynamic_cast<MCParticle*>( colmcp->getElementAt( i ) ) ;
           _mcpmap.insert(std::map<MCParticle*,int>::value_type(p,i));
        }

        for(int i=0; i< nMCP ; i++){

            MCParticle* p = dynamic_cast<MCParticle*>( colmcp->getElementAt( i ) ) ;

            // keep index. useful to compare with outputs of dumpevent.
            _data.mcp_index[i] = i;

            // keep parents info
            int nParents = p->getParents().size(); 
            if ( nParents > NMAX_PARENTS ) {
               std::cerr << " !!! NOTICE nParents ( = " << nParents << ") exceeds NMAX_PARENTS ( = " << NMAX_PARENTS << ")." << std::endl;
               std::cerr << " event = " << _nEvt << " index = " << _mcpmap.find(p)->second << std::endl;
               std::cerr << " The entries more than " << NMAX_PARENTS << " will be discarded." << std::endl;
               nParents = NMAX_PARENTS;
            }
            _data.mcp_nparents[i] = nParents;

            for (int j = 0; j < nParents; j++) {
              _data.mcp_parentIndex[i][j] = _mcpmap.find(p->getParents()[j])->second;
            }

            // keep daughters info
            int nDaughters = p->getDaughters().size();
            if ( nDaughters > NMAX_DAUGHTERS ) {
               std::cerr << " !!! NOTICE nDaughters ( = " << nDaughters << ") exceeds NMAX_DAUGHTERS ( = " << NMAX_DAUGHTERS << ")." << std::endl;
               std::cerr << " event = " << _nEvt << " index = " << _mcpmap.find(p)->second << std::endl;
               std::cerr << " The entries more than " << NMAX_DAUGHTERS << " will be discarded." << std::endl;
               //for (int j = 0; j < nDaughters-1; j++) {
               //  std::cerr << " # " << j << " PID:" << p->getDaughters()[j]->getPDG() << ", ";
               //}
               //std::cerr << " # " << nDaughters-1 << " PID:" << p->getDaughters()[nDaughters-1]->getPDG() << std::endl;
               //std::abort();
               nDaughters = NMAX_DAUGHTERS;
            }
            _data.mcp_ndaughters[i] = nDaughters;

            for (int j = 0; j < nDaughters; j++) {
              _data.mcp_daughterIndex[i][j] = _mcpmap.find(p->getDaughters()[j])->second;
            }

            _data.mcp_e[i]     = p->getEnergy(); 
            float px = p->getMomentum()[0];
            float py = p->getMomentum()[1];
            float pz = p->getMomentum()[2];
            _data.mcp_px[i]    = px;
            _data.mcp_py[i]    = py;
            _data.mcp_pz[i]    = pz; 
            TVector3 pv(px,py,pz);
            _data.mcp_pt[i]    = pv.Pt(); 
            float px_bcalcoord = _bg*pv.Mag() + _g * px; 
            _data.mcp_px_bcalcoord[i] = px_bcalcoord; 
            _data.mcp_pt_bcalcoord[i] = TMath::Sqrt(px_bcalcoord*px_bcalcoord+py*py); 
            _data.mcp_phi[i]   = pv.Phi(); 
            //_data.mcp_theta[i] = pv.Theta(); // need to consider 2pi = 0.
            _data.mcp_theta[i] = (pz>0)?TMath::ATan(pv.Perp()/pz):TMath::ATan(pv.Perp()/pz)+TMath::Pi(); 
            _data.mcp_chrg[i]  = p->getCharge();
            _data.mcp_startx[i] = float(p->getVertex()[0]);
            _data.mcp_starty[i] = float(p->getVertex()[1]);
            _data.mcp_startz[i] = float(p->getVertex()[2]);
            _data.mcp_endx[i]   = float(p->getEndpoint()[0]);
            _data.mcp_endy[i]   = float(p->getEndpoint()[1]);
            _data.mcp_endz[i]   = float(p->getEndpoint()[2]);
            _data.mcp_pdg[i]   = p->getPDG();
            _data.mcp_genstatus[i] = p->getGeneratorStatus();
            _data.mcp_simstatus[i] = p->getSimulatorStatus();
            _data.mcp_iscreatedinsim[i] = p->isCreatedInSimulation();
            _data.mcp_isoverlay[i] = p->isOverlay();
            _data.mcp_hasLeftDetector[i] = p->hasLeftDetector();

            _data.mcp_isFromBeambkg[i] = isFromBeambackground(p);
            _data.mcp_isOriginatedFromISR[i] = isOriginatedFromISR(p);
        } 
    }


    float photon_ptmax  = -99999.;
    float ptmaxphoton_e = -99999.;
    float ptmaxphoton_phi_bcalcoord = -99999.;
    float ptmaxphoton_theta_bcalcoord = -99999.;
    float photon_emax   = -99999.;
    float emaxphoton_pt_bcalcoord = -99999.;
    float emaxphoton_phi_bcalcoord = -99999.;
    float emaxphoton_theta_bcalcoord = -99999.;
    if( colpfo != NULL ){

        int nPFO = colpfo->getNumberOfElements()  ;
        if (nPFO > NMAX_PFOS) {
           std::cerr << " !!! ERROR nPFO ( = " << nPFO << ") exceeds NMAX_PFOS ( = " << NMAX_PFOS << ")." << std::endl;
           std::abort();
        }
        _data.npfos = nPFO;

        if( colmcpforel != NULL ) _navpfo = new LCRelationNavigator( colmcpforel );

        int icalhits = 0;
        for(int i=0; i< nPFO ; i++){

            _data.mcr_index[i] = 0;
            _data.mcr_weight[i] = 0;
            

            ReconstructedParticle* p = dynamic_cast<ReconstructedParticle*>( colpfo->getElementAt( i ) ) ;

            // TRK info
            const EVENT::TrackVec & trkvec = p->getTracks();
            // CAL info
            const EVENT::ClusterVec& clusvec = p->getClusters();

            // MC Relation
            MCParticle* mcr = 0;
            if (_navpfo) {
              //int nmcr = _navpfo->getRelatedToWeights( p ).size();
              int nmcr = _navpfo->getRelatedToObjects( p ).size();
              _data.nmcr[i] = nmcr; 
              if ( nmcr > 0 ) {
                 //mcr = dynamic_cast< MCParticle *> ( _navpfo->getRelatedToObjects( p )[0] );
                 mcr = getBestMCParticleOf(p,_navpfo);
                 //std::cerr << "MCRelation event = " << _nEvt << " mcr = " << mcr << " index = " << _mcpmap.find(mcr)->second << " ipfo = " << i << "/" << nPFO << "."<< std::endl;
                 _data.mcr_index[i] = _mcpmap.find(mcr)->second;
                 //std::cerr << _data.mcr_index[i]<< " " << isOriginatedFromIndex8(mcr) << std::endl;
                 if (mcr->getParents().size()) {
                   //std::cerr << "                   parent index = " << _mcpmap.find(mcr->getParents()[0])->second << std::endl;
                   int nParents = mcr->getParents().size(); 
                   _data.mcr_nparents[i] = nParents;
                   for (int j = 0; j < nParents; j++) {
                     _data.mcr_parentIndex[i][j] = _mcpmap.find(mcr->getParents()[j])->second;
                   }

                   int nDaughters = mcr->getDaughters().size(); 
                   _data.mcr_ndaughters[i] = nDaughters;
                   for (int j = 0; j < nDaughters; j++) {
                     _data.mcr_daughterIndex[i][j] = _mcpmap.find(mcr->getDaughters()[j])->second;
                   }
                 }
                 _data.mcr_weight[i] = _navpfo->getRelatedToWeights( p )[0];
                 _data.mcr_e[i]     = mcr->getEnergy(); 
                 float px = mcr->getMomentum()[0];
                 float py = mcr->getMomentum()[1];
                 float pz = mcr->getMomentum()[2];
                 _data.mcr_px[i]    = px;
                 _data.mcr_py[i]    = py;
                 _data.mcr_pz[i]    = pz; 
                 TVector3 pv(px,py,pz);
                 _data.mcr_pt[i]    = pv.Pt(); 
                 float px_bcalcoord = _bg*pv.Mag() + _g * px; 
                 _data.mcr_px_bcalcoord[i] = px_bcalcoord; 
                 _data.mcr_pt_bcalcoord[i] = TMath::Sqrt(px_bcalcoord*px_bcalcoord+py*py); 
                 _data.mcr_phi[i]   = pv.Phi(); 
                 //_data.mcr_theta[i] = pv.Theta(); // need to consider 2pi = 0.
                 //_data.mcr_theta[i] = TMath::ATan(pv.Perp()/pz); 
                 _data.mcr_theta[i] = (pz>0)?TMath::ATan(pv.Perp()/pz):TMath::ATan(pv.Perp()/pz)+TMath::Pi(); 
                 _data.mcr_chrg[i]  = mcr->getCharge();
                 _data.mcr_pdg[i]   = mcr->getPDG();
                 _data.mcr_genstatus[i] = mcr->getGeneratorStatus();
                 _data.mcr_simstatus[i] = mcr->getSimulatorStatus();
                 _data.mcr_iscreatedinsim[i] = mcr->isCreatedInSimulation();
                 _data.mcr_isoverlay[i] = mcr->isOverlay();
                 _data.mcr_hasLeftDetector[i] = mcr->hasLeftDetector();
                 _data.mcr_isFromBeambkg[i] = isFromBeambackground(mcr);
                 _data.mcr_isOriginatedFromISR[i] = isOriginatedFromISR(mcr);
              }
            }

            _data.pfo_e[i]     = p->getEnergy(); 
            float px = p->getMomentum()[0];
            float py = p->getMomentum()[1];
            float pz = p->getMomentum()[2];
            _data.pfo_px[i]    = px;
            _data.pfo_py[i]    = py;
            _data.pfo_pz[i]    = pz; 
            TVector3 pv(px,py,pz);
            _data.pfo_pt[i]    = pv.Pt(); 
            float px_bcalcoord = _bg*pv.Mag() + _g * px; 
            TVector3 pv_bcalcoord(px_bcalcoord,py,pz);
            _data.pfo_px_bcalcoord[i] = px_bcalcoord; 
            _data.pfo_pt_bcalcoord[i] = TMath::Sqrt(px_bcalcoord*px_bcalcoord+py*py); 
            _data.pfo_phi[i]   = pv.Phi(); 
            //_data.pfo_theta[i] = pv.Theta(); // need to consider 2pi = 0.
            //_data.pfo_theta[i] = TMath::ATan(pv.Perp()/pz); 
            _data.pfo_theta[i] = (pz>0)?TMath::ATan(pv.Perp()/pz):TMath::ATan(pv.Perp()/pz)+TMath::Pi(); 
            _data.pfo_chrg[i]  = p->getCharge();
            _data.pfo_pdg[i]   = p->getType();
            _data.pfo_goodnessOfPid[i]   = p->getGoodnessOfPID();

            // find a photon info having E-max and Pt-max
            if (_data.pfo_pdg[i]==22) {
              if (p->getEnergy()>photon_emax) {
                 photon_emax = p->getEnergy();
                 emaxphoton_pt_bcalcoord = _data.pfo_pt_bcalcoord[i];
                 emaxphoton_phi_bcalcoord = TMath::ATan2(_data.pfo_py[i],_data.pfo_px_bcalcoord[i]);
                 emaxphoton_theta_bcalcoord = (pv_bcalcoord.Z()>0)?TMath::ATan(pv_bcalcoord.Perp()/pv_bcalcoord.Z()):TMath::ATan(pv_bcalcoord.Perp()/pv_bcalcoord.Z())+TMath::Pi(); 
TMath::ATan2(_data.pfo_py[i],_data.pfo_px_bcalcoord[i]);
              }
              if (_data.pfo_pt_bcalcoord[i]>photon_ptmax) {
                 photon_ptmax = _data.pfo_pt_bcalcoord[i];
                 ptmaxphoton_e = _data.pfo_e[i];
                 ptmaxphoton_phi_bcalcoord = TMath::ATan2(_data.pfo_py[i],_data.pfo_px_bcalcoord[i]);
                 ptmaxphoton_theta_bcalcoord = (pv_bcalcoord.Z()>0)?TMath::ATan(pv_bcalcoord.Perp()/pv_bcalcoord.Z()):TMath::ATan(pv_bcalcoord.Perp()/pv_bcalcoord.Z())+TMath::Pi(); 
              }
            }           

            //_data.pfo_startx[i]   = float(p->getStartVertex()->getPosition()[0]);
            //_data.pfo_starty[i]   = float(p->getStartVertex()->getPosition()[1]);
            //_data.pfo_startz[i]   = float(p->getStartVertex()->getPosition()[2]);
            //_data.pfo_endx[i]   = float(p->getEndVertex()->getPosition()[0]);
            //_data.pfo_endy[i]   = float(p->getEndVertex()->getPosition()[1]);
            //_data.pfo_endz[i]   = float(p->getEndVertex()->getPosition()[2]);
        
            // fill first track info
            _data.pfo_ntrk[i]  = trkvec.size();
            if (trkvec.size()>0) {
              const Track* trk = trkvec[0];
              _data.pfo_d0[i] = trk->getD0();
              _data.pfo_z0[i] = trk->getZ0();
              _data.pfo_trkphi[i] = trk->getPhi();
              _data.pfo_omega[i] = trk->getOmega();
              _data.pfo_tanlambda[i] = trk->getTanLambda();
              _data.pfo_d0sig[i] = trk->getD0()/sqrt(trk->getCovMatrix()[0]);
              _data.pfo_z0sig[i] = trk->getZ0()/sqrt(trk->getCovMatrix()[9]);
            }

            // fill sum of cluster info
            int nclrs = clusvec.size();
            if (nclrs > NMAX_CLRS) {
               std::cerr << " !!! ERROR nclrs ( = " << nclrs << ") exceeds NMAX_CLRS ( = " << NMAX_CLRS << ")." << std::endl;
               std::abort();
            }
            _data.pfo_nclus[i] = nclrs;
            if (clusvec.size()>0) {
              float xsum = 0.;
              float ysum = 0.;
              float zsum = 0.;
              for ( ClusterVec::const_iterator iCluster=clusvec.begin();
                    iCluster!=clusvec.end(); ++iCluster) {
                const Cluster* cls = *iCluster;
                const float* xp = cls->getPosition();
                xsum += xp[0]; 
                ysum += xp[1];
                zsum += xp[2]; 
                _data.pfo_ecal_e[i]  += cls->getSubdetectorEnergies()[0];
                _data.pfo_hcal_e[i]  += cls->getSubdetectorEnergies()[1];
                _data.pfo_yoke_e[i]  += cls->getSubdetectorEnergies()[2];
                _data.pfo_lcal_e[i]  += cls->getSubdetectorEnergies()[3];
                _data.pfo_lhcal_e[i] += cls->getSubdetectorEnergies()[4];
                _data.pfo_bcal_e[i]  += cls->getSubdetectorEnergies()[5];

                // Note that there is no hit info in DST files.
                const EVENT::CalorimeterHitVec & calhits = cls->getCalorimeterHits();
                for ( CalorimeterHitVec::const_iterator iCalhit=calhits.begin();
                    iCalhit!=calhits.end(); ++iCalhit) {
                  const CalorimeterHit* calhit = *iCalhit;
                  const float* xp = calhit->getPosition();
                  _data.clr_x[icalhits] = xp[0];
                  _data.clr_y[icalhits] = xp[1];
                  _data.clr_z[icalhits] = xp[2];
                  icalhits++;
                }
              }
              _data.pfo_cal_x[i] = xsum / nclrs;
              _data.pfo_cal_y[i] = ysum / nclrs;
              _data.pfo_cal_z[i] = zsum / nclrs;
            }
        }

        _data.emaxphoton_pt_bcalcoord  = emaxphoton_pt_bcalcoord;
        _data.emaxphoton_phi_bcalcoord = emaxphoton_phi_bcalcoord;
        _data.emaxphoton_theta_bcalcoord = emaxphoton_theta_bcalcoord;
        _data.emaxphoton_e             = photon_emax;
        _data.ptmaxphoton_pt_bcalcoord = photon_ptmax;
        _data.ptmaxphoton_phi_bcalcoord = ptmaxphoton_phi_bcalcoord;
        _data.ptmaxphoton_theta_bcalcoord = ptmaxphoton_theta_bcalcoord;
        _data.ptmaxphoton_e            = ptmaxphoton_e;

        _data.nclrhits = icalhits;
        delete _navpfo;
        _navpfo = 0;
    }

    if( colbcal != NULL ){

        int nBCal = colbcal->getNumberOfElements()  ;
        _data.nbcalclrs = nBCal;
        //std::cerr << "#### nBCal = " << nBCal << std::endl;
        for (int i = 0; i < nBCal; i++) {
           ReconstructedParticle* p = dynamic_cast<ReconstructedParticle*>( colbcal->getElementAt( i ) ) ;

           // CAL info
           const EVENT::ClusterVec& clusvec = p->getClusters();
#if 0
           _data.nbcalhits[i] = clusvec.size();
           for (int icalhits = 0; icalhits < clusvec.size(); icalhits++) {
             _data.bcal_e[icalhits] = clusvec[icalhits]->getEnergy();
             TVector3 xp(clusvec[icalhits]->getPosition());
             _data.bcal_x[icalhits] = xp.X();
             _data.bcal_y[icalhits] = xp.Y();
             _data.bcal_z[icalhits] = xp.Z();
             _data.bcal_phi[icalhits]   = xp.Phi(); 
             _data.bcal_theta[icalhits] = (xp.Z()>0)?TMath::ATan(xp.Perp()/xp.Z()):TMath::ATan(xp.Perp()/xp.Z())+TMath::Pi(); 
           }
#else // it turned out that clusvec.size is always 1 if exists.
             _data.bcal_e[i] = clusvec[0]->getEnergy();
             TVector3 xp(clusvec[0]->getPosition());
             _data.bcal_x[i] = xp.X();
             _data.bcal_y[i] = xp.Y();
             _data.bcal_z[i] = xp.Z();
             _data.bcal_phi[i]   = xp.Phi(); 
             _data.bcal_theta[i] = (xp.Z()>0)?TMath::ATan(xp.Perp()/xp.Z()):TMath::ATan(xp.Perp()/xp.Z())+TMath::Pi(); 
#endif
        }
    }

    //-- note: this will not be printed if compiled w/o MARLINDEBUG=1 !

    streamlog_out(DEBUG) << "   processing event: " << evt->getEventNumber() 
        << "   in run:  " << evt->getRunNumber() << std::endl ;


    _data.evt = _nEvt;

    _evtdata->Fill(); 
//std::cerr << "End Event " << std::endl;

}



void MonoPhotonProcessor::check( LCEvent * evt ) { 
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}


void MonoPhotonProcessor::end(){ 

       std::cout << "   end called  " << std::endl ;
       _otfile->Write();
       //_otfile->Close();
       //delete _otfile;

       std::cout << "MonoPhotonProcessor::end()  " << name() 
     	    << " processed " << _nEvt << " events in " << _nRun << " runs "
     	    << std::endl ;

}

void MonoPhotonProcessor::makeNTuple() {

  // Output root file
  _otfile    = new TFile( _rootfilename.c_str() , "RECREATE" );

  EVTFILLDATA &d = _data;

  /** Define root tree
  */
  _evtdata  = new TTree( "evtdata" , "events" );
  _evtdata->Branch( "evt"             , &d.evt             , "evt/I"           );
  _evtdata->Branch( "npfos"           , &d.npfos           , "npfos/I"         );
  _evtdata->Branch( "pfo_e"           , &d.pfo_e           , "pfo_e[npfos]"          );
  _evtdata->Branch( "pfo_px"          , &d.pfo_px          , "pfo_px[npfos]"         );
  _evtdata->Branch( "pfo_py"          , &d.pfo_py          , "pfo_py[npfos]"         );
  _evtdata->Branch( "pfo_pz"          , &d.pfo_pz          , "pfo_pz[npfos]"         );
  _evtdata->Branch( "pfo_pt"          , &d.pfo_pt          , "pfo_pt[npfos]"         );
  _evtdata->Branch( "pfo_px_bcalcoord", &d.pfo_px_bcalcoord, "pfo_px_bcalcoord[npfos]");
  _evtdata->Branch( "pfo_pt_bcalcoord", &d.pfo_pt_bcalcoord, "pfo_pt_bcalcoord[npfos]");
  _evtdata->Branch( "pfo_phi"         , &d.pfo_phi         , "pfo_phi[npfos]"        );
  _evtdata->Branch( "pfo_theta"       , &d.pfo_theta       , "pfo_theta[npfos]"      );
  //_evtdata->Branch( "pfo_startx"      , &d.pfo_startx      , "pfo_startx[npfos]"     );
  //_evtdata->Branch( "pfo_starty"      , &d.pfo_starty      , "pfo_starty[npfos]"     );
  //_evtdata->Branch( "pfo_startz"      , &d.pfo_startz      , "pfo_startz[npfos]"     );
  //_evtdata->Branch( "pfo_endx"        , &d.pfo_endx        , "pfo_endx[npfos]"       );
  //_evtdata->Branch( "pfo_endy"        , &d.pfo_endy        , "pfo_endy[npfos]"       );
  //_evtdata->Branch( "pfo_endz"        , &d.pfo_endz        , "pfo_endz[npfos]"       );
  _evtdata->Branch( "pfo_chrg"        , &d.pfo_chrg        , "pfo_chrg[npfos]"       );
  _evtdata->Branch( "pfo_pdg"         , &d.pfo_pdg         , "pfo_pdg[npfos]/I"      );
  _evtdata->Branch( "pfo_ntrk"        , &d.pfo_ntrk        , "pfo_ntrk[npfos]/I"     );
  _evtdata->Branch( "pfo_d0"          , &d.pfo_d0          , "pfo_d0[npfos]"         );
  _evtdata->Branch( "pfo_d0sig"       , &d.pfo_d0sig       , "pfo_d0sig[npfos]"      );
  _evtdata->Branch( "pfo_z0"          , &d.pfo_z0          , "pfo_z0[npfos]"         );
  _evtdata->Branch( "pfo_z0sig"       , &d.pfo_z0sig       , "pfo_z0sig[npfos]"      );
  _evtdata->Branch( "pfo_trkphi"      , &d.pfo_trkphi      , "pfo_trkphi[npfos]"     );
  _evtdata->Branch( "pfo_omega"       , &d.pfo_omega       , "pfo_omega[npfos]"      );
  _evtdata->Branch( "pfo_tanlambda"   , &d.pfo_tanlambda   , "pfo_tanlambda[npfos]"  );
  _evtdata->Branch( "pfo_nclus"       , &d.pfo_nclus       , "pfo_nclus[npfos]/I"    );
  _evtdata->Branch( "pfo_cal_x"       , &d.pfo_cal_x       , "pfo_cal_x[npfos]"      );
  _evtdata->Branch( "pfo_cal_y"       , &d.pfo_cal_y       , "pfo_cal_y[npfos]"      );
  _evtdata->Branch( "pfo_cal_z"       , &d.pfo_cal_z       , "pfo_cal_z[npfos]"      );
  _evtdata->Branch( "pfo_ecal_e"      , &d.pfo_ecal_e      , "pfo_ecal_e[npfos]"     );
  _evtdata->Branch( "pfo_hcal_e"      , &d.pfo_hcal_e      , "pfo_hcal_e[npfos]"     );
  _evtdata->Branch( "pfo_yoke_e"      , &d.pfo_yoke_e      , "pfo_yoke_e[npfos]"     );
  _evtdata->Branch( "pfo_lcal_e"      , &d.pfo_lcal_e      , "pfo_lcal_e[npfos]"     );
  _evtdata->Branch( "pfo_lhcal_e"     , &d.pfo_lhcal_e     , "pfo_lhcal_e[npfos]"    );
  _evtdata->Branch( "pfo_bcal_e"      , &d.pfo_bcal_e      , "pfo_bcal_e[npfos]"     );
  _evtdata->Branch( "emaxphoton_pt_bcalcoord"  , &d.emaxphoton_pt_bcalcoord  , "emaxphoton_pt_bcalcoord"  );
  _evtdata->Branch( "emaxphoton_e"             , &d.emaxphoton_e             , "emaxphoton_e"             );
  _evtdata->Branch( "ptmaxphoton_pt_bcalcoord" , &d.ptmaxphoton_pt_bcalcoord , "ptmaxphoton_pt_bcalcoord" );
  _evtdata->Branch( "ptmaxphoton_e"            , &d.ptmaxphoton_e            , "ptmaxphoton_e"            );
  _evtdata->Branch( "ptmaxphoton_phi_bcalcoord"            , &d.ptmaxphoton_phi_bcalcoord            , "ptmaxphoton_phi_bcalcoord"            );
  _evtdata->Branch( "ptmaxphoton_theta_bcalcoord"            , &d.ptmaxphoton_theta_bcalcoord            , "ptmaxphoton_theta_bcalcoord"            );
  _evtdata->Branch( "emaxphoton_phi_bcalcoord"            , &d.emaxphoton_phi_bcalcoord            , "emaxphoton_phi_bcalcoord"            );
  _evtdata->Branch( "emaxphoton_theta_bcalcoord"            , &d.emaxphoton_theta_bcalcoord            , "emaxphoton_theta_bcalcoord"            );

  _evtdata->Branch( "nmcr"            , &d.nmcr            , "nmcr[npfos]/I"         );
  _evtdata->Branch( "mcr_weight"      , &d.mcr_weight      , "mcr_weight[npfos]"     );
  _evtdata->Branch( "mcr_index"       , &d.mcr_index       , "mcr_index[npfos]/I"    );
  _evtdata->Branch( "mcr_e"           , &d.mcr_e           , "mcr_e[npfos]"          );
  _evtdata->Branch( "mcr_px"          , &d.mcr_px          , "mcr_px[npfos]"         );
  _evtdata->Branch( "mcr_py"          , &d.mcr_py          , "mcr_py[npfos]"         );
  _evtdata->Branch( "mcr_pz"          , &d.mcr_pz          , "mcr_pz[npfos]"         );
  _evtdata->Branch( "mcr_pt"          , &d.mcr_pt          , "mcr_pt[npfos]"         );
  _evtdata->Branch( "mcr_px_bcalcoord", &d.mcr_px_bcalcoord, "mcr_px_bcalcoord[npfos]");
  _evtdata->Branch( "mcr_pt_bcalcoord", &d.mcr_pt_bcalcoord, "mcr_pt_bcalcoord[npfos]");
  _evtdata->Branch( "mcr_phi"         , &d.mcr_phi         , "mcr_phi[npfos]"        );
  _evtdata->Branch( "mcr_theta"       , &d.mcr_theta       , "mcr_theta[npfos]"      );
  _evtdata->Branch( "mcr_chrg"        , &d.mcr_chrg        , "mcr_chrg[npfos]"       );
  _evtdata->Branch( "mcr_pdg"         , &d.mcr_pdg         , "mcr_pdg[npfos]/I"      );
  _evtdata->Branch( "mcr_genstatus"   , &d.mcr_genstatus   , "mcr_genstatus[npfos]/I");
  _evtdata->Branch( "mcr_startx"      , &d.mcr_startx      , "mcr_startx[npfos]"     );
  _evtdata->Branch( "mcr_starty"      , &d.mcr_starty      , "mcr_starty[npfos]"     );
  _evtdata->Branch( "mcr_startz"      , &d.mcr_startz      , "mcr_startz[npfos]"     );
  _evtdata->Branch( "mcr_endx"        , &d.mcr_endx        , "mcr_endx[npfos]"       );
  _evtdata->Branch( "mcr_endy"        , &d.mcr_endy        , "mcr_endy[npfos]"       );
  _evtdata->Branch( "mcr_endz"        , &d.mcr_endz        , "mcr_endz[npfos]"       );
  _evtdata->Branch( "mcr_pdg"         , &d.mcr_pdg         , "mcr_pdg[npfos]/I"      );
  _evtdata->Branch( "mcr_nparents"    , &d.mcr_nparents    , "mcr_nparents[npfos]/I" );
  _evtdata->Branch( "mcr_parentIndex" , &d.mcr_parentIndex , "mcr_parentIndex[npfos][10]/I" );
  _evtdata->Branch( "mcr_ndaughters"    , &d.mcr_ndaughters    , "mcr_ndaughters[npfos]/I" );
  _evtdata->Branch( "mcr_daughterIndex" , &d.mcr_daughterIndex , "mcr_daughterIndex[npfos][10]/I" );
  _evtdata->Branch( "mcr_simstatus"   , &d.mcr_simstatus   , "mcr_simstatus[npfos]/I");
  _evtdata->Branch( "mcr_iscreatedinsim"   , &d.mcr_iscreatedinsim   , "mcr_iscreatedinsim[npfos]/O");
  _evtdata->Branch( "mcr_isoverlay"   , &d.mcr_isoverlay   , "mcr_isoverlay[npfos]/O");
  _evtdata->Branch( "mcr_hasLeftDetector"   , &d.mcr_hasLeftDetector   , "mcr_hasLeftDetector[npfos]/O");
  _evtdata->Branch( "mcr_isFromBeambkg", d.mcr_isFromBeambkg, "mcr_isFromBeambkg[npfos]/O");
  _evtdata->Branch( "mcr_isOriginatedFromISR", d.mcr_isOriginatedFromISR, "mcr_isOriginatedFromISR[npfos]/O");

  _evtdata->Branch( "nmcps"           , &d.nmcps           , "nmcps/I"               );
  _evtdata->Branch( "ipx"             , &d.ipx             , "ipx"                   );
  _evtdata->Branch( "ipy"             , &d.ipy             , "ipy"                   );
  _evtdata->Branch( "ipz"             , &d.ipz             , "ipz"                   );
  _evtdata->Branch( "mcp_index"       , &d.mcp_index       , "mcp_index[nmcps]/I"    );
  _evtdata->Branch( "mcp_e"           , &d.mcp_e           , "mcp_e[nmcps]"          );
  _evtdata->Branch( "mcp_px"          , &d.mcp_px          , "mcp_px[nmcps]"         );
  _evtdata->Branch( "mcp_py"          , &d.mcp_py          , "mcp_py[nmcps]"         );
  _evtdata->Branch( "mcp_pz"          , &d.mcp_pz          , "mcp_pz[nmcps]"         );
  _evtdata->Branch( "mcp_pt"          , &d.mcp_pt          , "mcp_pt[nmcps]"         );
  _evtdata->Branch( "mcp_px_bcalcoord", &d.mcp_px_bcalcoord, "mcp_px_bcalcoord[nmcps]");
  _evtdata->Branch( "mcp_pt_bcalcoord", &d.mcp_pt_bcalcoord, "mcp_pt_bcalcoord[nmcps]");
  _evtdata->Branch( "mcp_phi"         , &d.mcp_phi         , "mcp_phi[nmcps]"        );
  _evtdata->Branch( "mcp_theta"       , &d.mcp_theta       , "mcp_theta[nmcps]"      );
  _evtdata->Branch( "mcp_chrg"        , &d.mcp_chrg        , "mcp_chrg[nmcps]"       );
  _evtdata->Branch( "mcp_startx"      , &d.mcp_startx      , "mcp_startx[nmcps]"     );
  _evtdata->Branch( "mcp_starty"      , &d.mcp_starty      , "mcp_starty[nmcps]"     );
  _evtdata->Branch( "mcp_startz"      , &d.mcp_startz      , "mcp_startz[nmcps]"     );
  _evtdata->Branch( "mcp_endx"        , &d.mcp_endx        , "mcp_endx[nmcps]"       );
  _evtdata->Branch( "mcp_endy"        , &d.mcp_endy        , "mcp_endy[nmcps]"       );
  _evtdata->Branch( "mcp_endz"        , &d.mcp_endz        , "mcp_endz[nmcps]"       );
  _evtdata->Branch( "mcp_pdg"         , &d.mcp_pdg         , "mcp_pdg[nmcps]/I"      );
  _evtdata->Branch( "mcp_nparents"    , &d.mcp_nparents    , "mcp_nparents[nmcps]/I" );
  _evtdata->Branch( "mcp_parentIndex" , &d.mcp_parentIndex , "mcp_parentIndex[nmcps][10]/I" );
  _evtdata->Branch( "mcp_ndaughters"    , &d.mcp_ndaughters    , "mcp_ndaughters[nmcps]/I" );
  _evtdata->Branch( "mcp_daughterIndex" , &d.mcp_daughterIndex , "mcp_daughterIndex[nmcps][10]/I" );
  _evtdata->Branch( "mcp_genstatus"   , &d.mcp_genstatus   , "mcp_genstatus[nmcps]/I");
  _evtdata->Branch( "mcp_simstatus"   , &d.mcp_simstatus   , "mcp_simstatus[nmcps]/I");
  _evtdata->Branch( "mcp_iscreatedinsim"   , &d.mcp_iscreatedinsim   , "mcp_iscreatedinsim[nmcps]/O");
  _evtdata->Branch( "mcp_isoverlay"   , &d.mcp_isoverlay   , "mcp_isoverlay[nmcps]/O");
  _evtdata->Branch( "mcp_hasLeftDetector"   , &d.mcp_hasLeftDetector   , "mcp_hasLeftDetector[nmcps]/O");
  _evtdata->Branch( "mcp_isFromBeambkg", d.mcp_isFromBeambkg, "mcp_isFromBeambkg[nmcps]/O");
  _evtdata->Branch( "mcp_isOriginatedFromISR", d.mcp_isOriginatedFromISR, "mcp_isOriginatedFromISR[nmcps]/O");
  _evtdata->Branch( "nclrhits"        , &d.nclrhits        , "nclrhits/I"            );
  _evtdata->Branch( "clr_x"           , &d.clr_x           , "clr_x[nclrhits]"       );
  _evtdata->Branch( "clr_y"           , &d.clr_y           , "clr_y[nclrhits]"       );
  _evtdata->Branch( "clr_z"           , &d.clr_z           , "clr_z[nclrhits]"       );
  _evtdata->Branch( "nbcalclrs"       , &d.nbcalclrs       , "nbcalclrs/I"            );
  //_evtdata->Branch( "nbcalhits"       , &d.nbcalhits       , "nbcalhits[nbcalclrs]/I"            );
  _evtdata->Branch( "bcal_e"           , &d.bcal_e           , "bcal_e[nbcalclrs]"       );
  _evtdata->Branch( "bcal_x"           , &d.bcal_x           , "bcal_x[nbcalclrs]"       );
  _evtdata->Branch( "bcal_y"           , &d.bcal_y           , "bcal_y[nbcalclrs]"       );
  _evtdata->Branch( "bcal_z"           , &d.bcal_z           , "bcal_z[nbcalclrs]"       );
  _evtdata->Branch( "bcal_phi"         , &d.bcal_phi         , "bcal_phi[nbcalclrs]"     );
  _evtdata->Branch( "bcal_theta"       , &d.bcal_theta       , "bcal_theta[nbcalclrs]"   );
  return;

}

TVector3 MonoPhotonProcessor::getIP(MCParticle* p) {
  MCParticle* mcp = p;
  while (mcp->getParents().size()) {
    mcp = mcp->getParents()[0];
  }
  TVector3 ip(mcp->getVertex());
  return ip;
}

MCParticle* MonoPhotonProcessor::getBestMCParticleOf(ReconstructedParticle* p, LCRelationNavigator* nav)
{
    // getting MC information
    int nrel = nav->getRelatedToObjects(p).size();

#ifdef __DEBUG__
std::cerr << "  ### new reco particle. pdg_reco = " << p->getType() << std::endl;
std::cerr << "    MCParticles linked to this object... ( # = " << nrel << " )" << std::endl;
#endif

    double wmax;
    MCParticle *best = 0;
    for (int imc = 0; imc < nrel; imc++ ) {

      MCParticle *mcp = dynamic_cast<MCParticle*>(nav->getRelatedToObjects(p)[imc]);

      double trkw = double((int(nav->getRelatedToWeights(p)[imc])%10000)/1000.);
      double calw = double((int(nav->getRelatedToWeights(p)[imc])/10000)/1000.);

      if (imc==0) {
        if (trkw>calw) wmax = trkw;
        else           wmax = calw;
        best = mcp;
      } else {
        if (trkw > wmax) {
          wmax = trkw;
          best = mcp;
        }
        if (calw > wmax) {
          wmax = calw;
          best = mcp;
        }
      }
#ifdef __DEBUG__
      std::cerr << "         " << imc << ") : pdg_mc = " << mcp->getPDG() 
                << ",  weight = " << nav->getRelatedToWeights(p)[imc] 
                << ", trkw = " << trkw 
                << ", calw = " << calw << std::endl;
#endif
   }
   return best;
}

bool MonoPhotonProcessor::isFromBeambackground(MCParticle* p)
{
   int nparents = p->getParents().size();
   for (int iparent = 0; iparent < nparents; iparent++) {
     MCParticle *parent = p->getParents()[iparent];
     bool retval = isFromBeambackground(parent);
     return retval;
   }
   std::map<MCParticle*,int>::iterator mcpitr = _mcpmap.find(p);
   if (mcpitr!=_mcpmap.end()) {
     if (mcpitr->second==0 || mcpitr->second==1) return false;
     //std::cerr << p->getPDG() << " index : " << mcpitr->second << std::endl;
   }
   return true;
}

bool MonoPhotonProcessor::isOriginatedFromISR(MCParticle* p)
{
   std::map<MCParticle*,int>::iterator mcpitr = _mcpmap.find(p);
   if (mcpitr!=_mcpmap.end()) {
     if (mcpitr->second>=8) { 
       if (mcpitr->second==8) return true;
       else if (mcpitr->second==9||mcpitr->second==10) {
          MCParticle* parent = 0;
          if (p->getParents().size()==2) parent = p->getParents()[0];
          std::map<MCParticle*,int>::iterator mcpitr2 = _mcpmap.find(parent);
          if (mcpitr2!=_mcpmap.end()) {
            if (mcpitr2->second==2) return true;
          }
       }
     }
   }
   int nparents = p->getParents().size();
   for (int iparent = 0; iparent < nparents; iparent++) {
     MCParticle *parent = p->getParents()[iparent];
     bool retval = isOriginatedFromISR(parent);
     return retval;
   }
   return false;
}
